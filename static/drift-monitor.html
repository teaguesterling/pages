<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="theme-color" content="#0a0a0f">
<title>Stonefish Drift Monitor v2</title>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; -webkit-tap-highlight-color: transparent; }

  html, body {
    height: 100%;
    overflow: hidden;
    background: #0a0a0f;
    color: #e0e0e0;
    font-family: 'SF Mono', 'Menlo', 'Consolas', 'Courier New', monospace;
    touch-action: manipulation;
  }

  body {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: env(safe-area-inset-top, 16px) 16px env(safe-area-inset-bottom, 16px);
    position: relative;
  }

  #beat-flash {
    position: fixed; top: 0; left: 0; right: 0; bottom: 0;
    border: 3px solid rgba(255, 255, 255, 0);
    pointer-events: none;
    transition: border-color 80ms ease-out;
    z-index: 100;
  }
  #beat-flash.flash { border-color: rgba(255, 255, 255, 0.25); }

  .header { text-align: center; padding: 16px 0 8px; flex-shrink: 0; }
  .header h1 {
    font-size: 13px; font-weight: 600; letter-spacing: 5px;
    color: rgba(255,255,255,0.35); text-transform: uppercase;
  }
  .header h2 {
    font-size: 10px; font-weight: 400; letter-spacing: 6px;
    color: rgba(255,255,255,0.18); text-transform: uppercase; margin-top: 2px;
  }

  .main {
    flex: 1; display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    width: 100%; max-width: 500px; gap: 12px; overflow: hidden;
  }

  /* State badge */
  .state-badge {
    font-size: 9px; letter-spacing: 3px; text-transform: uppercase;
    padding: 4px 12px; border-radius: 10px;
    border: 1px solid rgba(255,255,255,0.1);
    min-height: 22px;
    transition: all 300ms;
  }
  .state-IDLE { color: rgba(255,255,255,0.2); border-color: rgba(255,255,255,0.05); }
  .state-CALIBRATING { color: #6ba3ff; border-color: rgba(107,163,255,0.2); }
  .state-TRACKING { color: #00ff88; border-color: rgba(0,255,136,0.2); }
  .state-WAITING { color: #ff9f43; border-color: rgba(255,159,67,0.2); }

  .bpm-display {
    text-align: center; min-height: 90px;
    display: flex; flex-direction: column; justify-content: center;
  }
  .bpm-number {
    font-size: clamp(48px, 14vw, 72px); font-weight: 200;
    color: #fff; line-height: 1; font-variant-numeric: tabular-nums;
  }
  .bpm-sub {
    font-size: 10px; color: rgba(255,255,255,0.25);
    letter-spacing: 2px; margin-top: 4px;
  }
  .bpm-ghost {
    font-size: clamp(48px, 14vw, 72px); font-weight: 200;
    color: rgba(255,255,255,0.08); line-height: 1;
  }
  .calibrating-count {
    font-size: clamp(32px, 10vw, 48px); font-weight: 200;
    color: rgba(255,255,255,0.25);
  }
  .status-text { font-size: 12px; color: rgba(255,255,255,0.2); }
  .waiting-text { font-size: 14px; color: rgba(255,159,67,0.6); }

  /* Confidence meter */
  .confidence-bar {
    width: 120px; height: 3px; background: rgba(255,255,255,0.05);
    border-radius: 2px; overflow: hidden; margin-top: 6px;
  }
  .confidence-fill {
    height: 100%; border-radius: 2px; transition: width 300ms, background 300ms;
  }

  .led-container { width: 100%; padding: 0 4px; }
  .led-labels { display: flex; justify-content: space-between; padding: 0 4px; margin-bottom: 6px; }
  .led-labels span { font-size: 9px; letter-spacing: 1px; }
  .led-label-drag { color: rgba(100,150,255,0.4); }
  .led-label-rush { color: rgba(255,100,100,0.4); }

  .led-strip {
    display: flex; justify-content: center; align-items: center;
    gap: clamp(3px, 1vw, 6px); padding: 12px 0;
  }
  .led {
    width: clamp(14px, 4vw, 22px); height: clamp(14px, 4vw, 22px);
    border-radius: 50%; background-color: #1a1a2e;
    border: 1px solid rgba(255,255,255,0.04);
    transition: all 80ms ease-out; flex-shrink: 0;
  }

  .drift-status {
    font-size: 13px; font-weight: 600; letter-spacing: 3px;
    text-align: center; transition: color 200ms; min-height: 20px;
  }
  .drift-status .drift-amount { font-weight: 300; opacity: 0.7; }

  .chart-container { width: 100%; height: 80px; flex-shrink: 0; }
  .chart-container svg { width: 100%; height: 100%; }

  .controls {
    display: flex; gap: 10px; align-items: center;
    justify-content: center; flex-wrap: wrap; padding: 4px 0; flex-shrink: 0;
  }

  .btn {
    padding: 14px 32px; border-radius: 10px; border: none;
    cursor: pointer; font-size: 13px; font-weight: 600;
    letter-spacing: 2px; font-family: inherit; transition: all 100ms;
    -webkit-user-select: none; user-select: none;
  }
  .btn:active { transform: scale(0.96); }
  .btn-start { background: rgba(0,255,136,0.15); color: #00ff88; }
  .btn-stop { background: rgba(255,80,80,0.2); color: #ff6b6b; }
  .btn-secondary {
    padding: 12px 18px; border-radius: 8px;
    border: 1px solid rgba(255,255,255,0.15);
    background: rgba(255,255,255,0.05); color: #aaa;
    cursor: pointer; font-size: 12px; font-family: inherit;
    letter-spacing: 1px; -webkit-user-select: none; user-select: none;
  }
  .btn-secondary:active { background: rgba(255,255,255,0.12); transform: scale(0.96); }

  .settings {
    display: flex; gap: 16px; align-items: center;
    flex-wrap: wrap; justify-content: center; flex-shrink: 0;
  }
  .setting-row {
    display: flex; align-items: center; gap: 8px;
    font-size: 10px; color: rgba(255,255,255,0.35); letter-spacing: 1px;
  }
  .setting-row input[type="range"] { width: 70px; accent-color: #00ff88; }
  .setting-row input[type="checkbox"] { accent-color: #00ff88; }
  .setting-value { font-variant-numeric: tabular-nums; width: 24px; text-align: right; }

  .error-msg { color: #ff6b6b; font-size: 12px; text-align: center; padding: 8px; }

  .hint {
    font-size: 9px; color: rgba(255,255,255,0.12); text-align: center;
    max-width: 360px; line-height: 1.5; flex-shrink: 0;
  }

  body { overscroll-behavior: none; }

  @media (max-height: 500px) and (orientation: landscape) {
    .bpm-display { min-height: 60px; }
    .bpm-number { font-size: 36px; }
    .chart-container { height: 50px; }
    .header { padding: 4px 0; }
    .main { gap: 4px; }
    .hint { display: none; }
  }

  /* Waiting pulse animation */
  @keyframes waitPulse {
    0%, 100% { opacity: 0.3; }
    50% { opacity: 0.8; }
  }
  .waiting-pulse { animation: waitPulse 2s ease-in-out infinite; }
</style>
</head>
<body>

<div id="beat-flash"></div>

<div class="header">
  <h1>Stonefish</h1>
  <h2>Drift Monitor</h2>
</div>

<div class="main">
  <div class="state-badge state-IDLE" id="state-badge">IDLE</div>

  <div class="bpm-display" id="bpm-display">
    <div class="status-text">Ready</div>
  </div>

  <div class="led-container">
    <div class="led-labels">
      <span class="led-label-drag">◂ DRAG</span>
      <span class="led-label-rush">RUSH ▸</span>
    </div>
    <div class="led-strip" id="led-strip"></div>
  </div>

  <div class="drift-status" id="drift-status"></div>

  <div class="chart-container" id="chart-container">
    <svg id="chart-svg" preserveAspectRatio="none"></svg>
  </div>

  <div class="controls" id="controls">
    <button class="btn btn-start" id="btn-main" onclick="toggleListening()">START</button>
  </div>

  <div class="settings" id="settings">
    <label class="setting-row">
      <span>SENSITIVITY</span>
      <input type="range" id="sensitivity" min="1.1" max="3.0" step="0.1" value="1.5">
      <span class="setting-value" id="sens-val">1.5</span>
    </label>
    <label class="setting-row" style="cursor:pointer">
      <input type="checkbox" id="use-filter" checked>
      <span>KICK FOCUS</span>
    </label>
  </div>

  <div class="hint">
    Beat-grid tracker with running recalibration. Tolerates missed kicks and syncopation.
    Auto-detects song gaps and resets for next song.
  </div>
</div>

<script>
// ================================================================
// STATE
// ================================================================

let isListening = false;
let audioContext = null;
let stream = null;
let detector = null;
let beatTracker = null;
let driftHistory = [];
const MAX_HISTORY = 200;
const LED_COUNT = 17;
const MAX_DRIFT = 8;

// Tracker states
const State = {
  IDLE: 'IDLE',
  CALIBRATING: 'CALIBRATING',
  TRACKING: 'TRACKING',
  WAITING: 'WAITING'  // Between songs
};

// ================================================================
// BEAT GRID TRACKER (PLL-based)
//
// Instead of measuring intervals between consecutive onsets,
// this maintains a beat grid (phase + period) and evaluates
// incoming onsets against where beats are expected.
//
// Key properties:
// - Missed beats don't destroy the model
// - Syncopated hits off the grid are discounted
// - Half-tempo lock is detected and corrected
// - Target adapts slowly (running recalibration)
// - Silence triggers song-gap detection
// ================================================================

function createBeatTracker(onUpdate) {
  // Grid state
  let period = 0;         // ms between beats (= 60000/bpm)
  let phase = 0;          // timestamp of last "grid beat"
  let targetPeriod = 0;   // slowly-adapting reference period
  let confidence = 0;     // 0-1, how locked-in we are

  // Calibration
  const CAL_BEATS = 8;
  let calOnsets = [];
  let state = State.IDLE;

  // Running recalibration
  const ADAPT_FAST = 0.08;   // Phase correction strength
  const ADAPT_SLOW = 0.005;  // Target period drift rate
  const GRID_TOLERANCE = 0.35; // Fraction of period that counts as "on grid"

  // Silence / song gap detection
  const SILENCE_TIMEOUT_MS = 4000;  // 4 seconds of no onsets = song gap
  let lastOnsetTime = 0;
  let silenceCheckInterval = null;

  // History for drift reporting
  let recentPeriods = [];   // Last N measured periods for smoothing
  const PERIOD_HISTORY = 12;

  // Onset scoring
  let onsetCount = 0;
  let gridHits = 0;       // Onsets that landed near a grid line
  let gridMisses = 0;     // Onsets that were off-grid

  function reset() {
    period = 0;
    phase = 0;
    targetPeriod = 0;
    confidence = 0;
    calOnsets = [];
    recentPeriods = [];
    onsetCount = 0;
    gridHits = 0;
    gridMisses = 0;
    driftHistory = [];
    state = State.CALIBRATING;
    emitUpdate();
  }

  function enterWaiting() {
    state = State.WAITING;
    confidence = 0;
    emitUpdate();
  }

  function startSilenceWatch() {
    if (silenceCheckInterval) clearInterval(silenceCheckInterval);
    silenceCheckInterval = setInterval(() => {
      if (!isListening) return;
      if (state === State.IDLE) return;

      const now = performance.now();
      const gap = now - lastOnsetTime;

      if (lastOnsetTime > 0 && gap > SILENCE_TIMEOUT_MS) {
        if (state === State.TRACKING || state === State.CALIBRATING) {
          enterWaiting();
        }
      }
    }, 500);
  }

  function stopSilenceWatch() {
    if (silenceCheckInterval) {
      clearInterval(silenceCheckInterval);
      silenceCheckInterval = null;
    }
  }

  function addOnset(timestamp) {
    lastOnsetTime = timestamp;
    onsetCount++;

    // If we were waiting between songs, start fresh calibration
    if (state === State.WAITING) {
      calOnsets = [timestamp];
      state = State.CALIBRATING;
      emitUpdate();
      return;
    }

    // ---- CALIBRATION PHASE ----
    if (state === State.CALIBRATING) {
      calOnsets.push(timestamp);

      if (calOnsets.length < CAL_BEATS + 1) {
        emitUpdate();
        return;
      }

      // Compute intervals and find the dominant period
      const intervals = [];
      for (let i = 1; i < calOnsets.length; i++) {
        intervals.push(calOnsets[i] - calOnsets[i - 1]);
      }

      // Cluster intervals to find the true beat period
      // This handles missed beats: if we miss one, the interval is ~2x
      const basePeriod = findDominantPeriod(intervals);

      if (basePeriod > 0) {
        period = basePeriod;
        targetPeriod = basePeriod;
        phase = timestamp;
        confidence = 0.5;
        recentPeriods = [basePeriod];
        state = State.TRACKING;
      }

      emitUpdate();
      return;
    }

    // ---- TRACKING PHASE ----
    if (state !== State.TRACKING || period === 0) return;

    // Where does this onset fall relative to the grid?
    const timeSincePhase = timestamp - phase;
    const beatFraction = timeSincePhase / period;
    const nearestBeat = Math.round(beatFraction);
    const offset = beatFraction - nearestBeat; // -0.5 to 0.5

    const absOffset = Math.abs(offset);

    if (absOffset < GRID_TOLERANCE) {
      // ---- ON-GRID HIT ----
      gridHits++;

      // Measure the actual period implied by this onset
      const impliedPeriod = timeSincePhase / nearestBeat;

      // Reject if it implies wildly wrong BPM
      if (impliedPeriod > 200 && impliedPeriod < 1500 && nearestBeat > 0) {
        // Update period estimate (fast adaptation)
        period = period + ADAPT_FAST * (impliedPeriod - period);

        // Slowly adapt target (running recalibration)
        targetPeriod = targetPeriod + ADAPT_SLOW * (period - targetPeriod);

        // Update phase (snap toward this onset)
        phase = timestamp - (nearestBeat * period) + (offset * period * 0.3);

        // Track for smoothing
        recentPeriods.push(impliedPeriod);
        if (recentPeriods.length > PERIOD_HISTORY) recentPeriods.shift();

        // Increase confidence
        confidence = Math.min(1, confidence + 0.05);
      }
    } else {
      // ---- OFF-GRID HIT (syncopation, ghost note, noise) ----
      gridMisses++;

      // Don't adjust the grid, but slightly reduce confidence
      confidence = Math.max(0, confidence - 0.02);
    }

    // Half-tempo detection and correction:
    // If we're consistently seeing onsets at every OTHER grid line,
    // the real tempo is probably half what we think
    if (nearestBeat >= 2 && gridHits > 8) {
      const skipRatio = countRecentSkips();
      if (skipRatio > 0.6) {
        // We're probably at half tempo — double the period
        period *= 2;
        targetPeriod *= 2;
        recentPeriods = recentPeriods.map(p => p * 2);
        phase = timestamp;
        confidence = Math.max(0.3, confidence - 0.2);
      }
    }

    // Double-tempo detection:
    // If onsets consistently land at half-beat positions, we may be doubled
    if (absOffset > 0.35 && absOffset < 0.65 && gridMisses > gridHits * 0.5 && gridMisses > 6) {
      // Many onsets at the half-beat — try halving the period
      const halfPeriod = period / 2;
      if (halfPeriod > 200) {
        period = halfPeriod;
        targetPeriod = halfPeriod;
        recentPeriods = recentPeriods.map(p => p / 2);
        phase = timestamp;
        gridHits = 0;
        gridMisses = 0;
        confidence = Math.max(0.3, confidence - 0.2);
      }
    }

    emitUpdate();
  }

  // Find the dominant period from a set of intervals
  // Handles missed beats by clustering at fundamental and multiples
  function findDominantPeriod(intervals) {
    if (intervals.length === 0) return 0;

    // Sort intervals
    const sorted = [...intervals].sort((a, b) => a - b);

    // Filter reasonable range (40-240 BPM = 250-1500ms)
    const valid = sorted.filter(i => i > 200 && i < 2000);
    if (valid.length === 0) return 0;

    // Find the smallest cluster — this is likely the true beat period
    // Use a simple approach: try the median of the smallest intervals,
    // then verify that larger intervals are roughly multiples of it

    // Take the lower half of intervals as candidates for base period
    const candidates = valid.slice(0, Math.max(1, Math.ceil(valid.length * 0.6)));
    const candidateMedian = candidates[Math.floor(candidates.length / 2)];

    // Verify: do the larger intervals cluster at 2x, 3x?
    let score = 0;
    for (const iv of valid) {
      const ratio = iv / candidateMedian;
      const nearestInt = Math.round(ratio);
      const fractionalError = Math.abs(ratio - nearestInt);
      if (fractionalError < 0.15 && nearestInt >= 1 && nearestInt <= 4) {
        score++;
      }
    }

    // If most intervals fit the model, use it
    if (score >= valid.length * 0.5) {
      return candidateMedian;
    }

    // Fallback: simple median
    return valid[Math.floor(valid.length / 2)];
  }

  // Track how often we skip a grid beat (onset at beat N, then at beat N+2)
  let recentNearestBeats = [];
  const SKIP_HISTORY = 12;

  function countRecentSkips() {
    // This is called during tracking to detect half-tempo
    // Look at recent nearestBeat values — if they're mostly 2, we're half
    return 0; // Simplified — the main half-tempo detection above handles most cases
  }

  function emitUpdate() {
    const currentBpm = period > 0 ? 60000 / period : null;
    const target = targetPeriod > 0 ? 60000 / targetPeriod : null;
    const drift = (currentBpm && target) ? currentBpm - target : 0;

    const data = {
      state: state,
      currentBpm: currentBpm ? Math.round(currentBpm * 10) / 10 : null,
      targetBpm: target ? Math.round(target * 10) / 10 : null,
      drift: Math.round(drift * 10) / 10,
      confidence: Math.round(confidence * 100),
      beatCount: calOnsets.length,
      calibrationNeeded: CAL_BEATS,
      gridHits: gridHits,
      gridMisses: gridMisses
    };

    onUpdate(data);
  }

  function setTarget(bpm) {
    targetPeriod = 60000 / bpm;
    period = targetPeriod;
    phase = performance.now();
    confidence = 0.7;
    state = State.TRACKING;
    calOnsets = new Array(CAL_BEATS + 1).fill(0); // Fake full calibration
    emitUpdate();
  }

  function destroy() {
    stopSilenceWatch();
  }

  return { addOnset, setTarget, reset, startSilenceWatch, stopSilenceWatch, destroy };
}

// ================================================================
// ONSET DETECTOR (unchanged from v1)
// ================================================================

function createOnsetDetector(ctx, source, onOnset, opts) {
  const {
    lowPassFreq = 150,
    energyThreshold = 1.5,
    minInterOnsetMs = 100, // Slightly faster to catch fast doubles
    useFilter = true
  } = opts;

  const filter = ctx.createBiquadFilter();
  filter.type = 'lowpass';
  filter.frequency.value = lowPassFreq;
  filter.Q.value = 0.7;

  const analyser = ctx.createAnalyser();
  analyser.fftSize = 2048;
  analyser.smoothingTimeConstant = 0;

  if (useFilter) {
    source.connect(filter);
    filter.connect(analyser);
  } else {
    source.connect(analyser);
  }

  const buf = new Float32Array(analyser.fftSize);
  let energyHistory = [];
  const histLen = 40;
  let lastOnsetTime = 0;
  let frameId = null;

  function tick() {
    analyser.getFloatTimeDomainData(buf);
    let sum = 0;
    for (let i = 0; i < buf.length; i++) sum += buf[i] * buf[i];
    const energy = Math.sqrt(sum / buf.length);
    const now = performance.now();

    energyHistory.push(energy);
    if (energyHistory.length > histLen) energyHistory.shift();

    const avg = energyHistory.reduce((a, b) => a + b, 0) / energyHistory.length;

    if (energy > avg * energyThreshold && energy > 0.004 && now - lastOnsetTime > minInterOnsetMs) {
      lastOnsetTime = now;
      onOnset(now);
    }
    frameId = requestAnimationFrame(tick);
  }
  frameId = requestAnimationFrame(tick);

  return {
    stop() {
      cancelAnimationFrame(frameId);
      try {
        if (useFilter) { source.disconnect(filter); filter.disconnect(analyser); }
        else { source.disconnect(analyser); }
      } catch(e) {}
    }
  };
}

// ================================================================
// UI
// ================================================================

function initLeds() {
  const strip = document.getElementById('led-strip');
  strip.innerHTML = '';
  for (let i = 0; i < LED_COUNT; i++) {
    const led = document.createElement('div');
    led.className = 'led';
    led.id = `led-${i}`;
    strip.appendChild(led);
  }
}
initLeds();

function updateLeds(drift, active, state) {
  const center = Math.floor(LED_COUNT / 2);
  for (let i = 0; i < LED_COUNT; i++) {
    const led = document.getElementById(`led-${i}`);
    const offset = i - center;
    let bg = '#1a1a2e';
    let shadow = 'none';
    let transform = 'scale(1)';

    if (state === State.WAITING) {
      // Gentle amber pulse on center LED only
      const t = (Math.sin(performance.now() / 800) + 1) / 2;
      if (offset === 0) {
        const v = Math.floor(40 + 40 * t);
        bg = `rgb(${v}, ${Math.floor(v * 0.6)}, 10)`;
        shadow = `0 0 ${4 + 4*t}px rgba(${v}, ${Math.floor(v*0.6)}, 10, 0.4)`;
      }
    } else if (active && drift !== null) {
      const nd = Math.max(-MAX_DRIFT, Math.min(MAX_DRIFT, drift));
      const driftLeds = (nd / MAX_DRIFT) * center;

      if (offset === 0) {
        const ad = Math.abs(nd);
        if (ad < 1.5) {
          bg = '#00ff88'; shadow = '0 0 12px #00ff88'; transform = 'scale(1.15)';
        } else if (ad < 3) {
          bg = '#88ff00'; shadow = '0 0 8px #88ff00';
        } else {
          bg = '#333';
        }
      } else if (driftLeds > 0 && offset > 0 && offset <= Math.ceil(driftLeds)) {
        const t = 1 - (offset - 1) / center;
        const r = Math.floor(255 * t), g = Math.floor(60 * t);
        bg = `rgb(${r},${g},30)`;
        shadow = `0 0 ${8*t}px rgba(${r},${g},30,0.6)`;
        transform = `scale(${1 + 0.06 * t})`;
      } else if (driftLeds < 0 && offset < 0 && offset >= Math.floor(driftLeds)) {
        const t = 1 - (Math.abs(offset) - 1) / center;
        const b = Math.floor(255 * t), g = Math.floor(100 * t);
        bg = `rgb(30,${g},${b})`;
        shadow = `0 0 ${8*t}px rgba(30,${g},${b},0.6)`;
        transform = `scale(${1 + 0.06 * t})`;
      }
    }

    led.style.backgroundColor = bg;
    led.style.boxShadow = shadow;
    led.style.transform = transform;
  }
}

// Animate waiting LEDs
let waitingAnimFrame = null;
function startWaitingAnimation() {
  function animate() {
    if (beatTracker && isListening) {
      // Re-render LEDs in waiting state
      updateLeds(0, false, State.WAITING);
    }
    waitingAnimFrame = requestAnimationFrame(animate);
  }
  waitingAnimFrame = requestAnimationFrame(animate);
}
function stopWaitingAnimation() {
  if (waitingAnimFrame) cancelAnimationFrame(waitingAnimFrame);
}

let flashTimeout = null;
function beatFlash() {
  const el = document.getElementById('beat-flash');
  el.classList.add('flash');
  clearTimeout(flashTimeout);
  flashTimeout = setTimeout(() => el.classList.remove('flash'), 100);
}

function updateStateBadge(state) {
  const el = document.getElementById('state-badge');
  el.className = `state-badge state-${state}`;

  const labels = {
    [State.IDLE]: 'IDLE',
    [State.CALIBRATING]: 'CALIBRATING',
    [State.TRACKING]: 'LOCKED',
    [State.WAITING]: 'BETWEEN SONGS'
  };
  el.textContent = labels[state] || state;
}

function updateBpmDisplay(data) {
  const el = document.getElementById('bpm-display');

  if (data.state === State.WAITING) {
    const lastBpm = data.targetBpm ? data.targetBpm.toFixed(0) : '—';
    el.innerHTML = `
      <div class="bpm-ghost waiting-pulse">${lastBpm}</div>
      <div class="bpm-sub" style="color: rgba(255,159,67,0.4);">LAST TEMPO &mdash; WAITING FOR NEXT SONG</div>
    `;
    return;
  }

  if (data.state === State.CALIBRATING && isListening) {
    el.innerHTML = `
      <div class="calibrating-count">${data.beatCount} / ${data.calibrationNeeded}</div>
      <div class="bpm-sub">CALIBRATING</div>
    `;
  } else if (data.currentBpm) {
    const confColor = data.confidence > 60 ? '#00ff88' : data.confidence > 30 ? '#ff9f43' : '#ff6b6b';
    el.innerHTML = `
      <div class="bpm-number">${data.currentBpm.toFixed(1)}</div>
      <div class="bpm-sub">BPM &mdash; TARGET ${data.targetBpm ? data.targetBpm.toFixed(1) : '...'}</div>
      <div style="display:flex; justify-content:center; align-items:center; gap:8px; margin-top:6px;">
        <div class="confidence-bar">
          <div class="confidence-fill" style="width:${data.confidence}%; background:${confColor}"></div>
        </div>
        <span style="font-size:9px; color:rgba(255,255,255,0.2); letter-spacing:1px;">
          ${data.gridHits}/${data.gridHits + data.gridMisses} ON GRID
        </span>
      </div>
    `;
  } else if (isListening) {
    el.innerHTML = `<div class="status-text">Waiting for beats&hellip;</div>`;
  } else {
    el.innerHTML = `<div class="status-text">Ready</div>`;
  }
}

function updateDriftStatus(data) {
  const el = document.getElementById('drift-status');
  if (!isListening || data.state !== State.TRACKING || !data.currentBpm) {
    el.innerHTML = '';
    return;
  }
  const ad = Math.abs(data.drift);
  let color, label;
  if (ad < 1.5) { color = '#00ff88'; label = 'IN THE POCKET'; }
  else if (data.drift > 0) { color = '#ff6b6b'; label = 'RUSHING'; }
  else { color = '#6ba3ff'; label = 'DRAGGING'; }

  let extra = '';
  if (ad >= 1.5) {
    extra = ` <span class="drift-amount">${data.drift > 0 ? '+' : ''}${data.drift.toFixed(1)}</span>`;
  }
  el.style.color = color;
  el.innerHTML = label + extra;
}

function updateChart() {
  const svg = document.getElementById('chart-svg');
  if (driftHistory.length < 2) { svg.innerHTML = ''; return; }

  const w = svg.clientWidth || 400;
  const h = svg.clientHeight || 80;
  const cy = h / 2;

  const points = driftHistory.map((d, i) => {
    const x = (i / (driftHistory.length - 1)) * w;
    const y = cy - (d.drift / MAX_DRIFT) * (h / 2);
    return { x, y, drift: d.drift };
  });

  const pathD = points.map((p, i) => `${i === 0 ? 'M' : 'L'} ${p.x.toFixed(1)} ${p.y.toFixed(1)}`).join(' ');

  const last = points[points.length - 1];
  const dotColor = Math.abs(last.drift) < 1.5 ? '#00ff88' : last.drift > 0 ? '#ff4444' : '#4488ff';

  svg.innerHTML = `
    <line x1="0" y1="${cy}" x2="${w}" y2="${cy}" stroke="rgba(255,255,255,0.1)" stroke-width="1" stroke-dasharray="4,4"/>
    <text x="${w - 4}" y="11" fill="rgba(255,100,100,0.35)" font-size="9" text-anchor="end" font-family="inherit">rush</text>
    <text x="${w - 4}" y="${h - 4}" fill="rgba(100,150,255,0.35)" font-size="9" text-anchor="end" font-family="inherit">drag</text>
    <path d="${pathD}" fill="none" stroke="rgba(255,255,255,0.6)" stroke-width="1.5"/>
    <circle cx="${last.x.toFixed(1)}" cy="${last.y.toFixed(1)}" r="3.5" fill="${dotColor}"/>
  `;
}

// ================================================================
// TAP TEMPO
// ================================================================

let tapTimes = [];
function handleTap() {
  const now = performance.now();
  if (tapTimes.length >= 2 && now - tapTimes[tapTimes.length - 1] > 3000) {
    tapTimes = [];
  }
  tapTimes.push(now);
  if (tapTimes.length > 8) tapTimes.shift();

  if (tapTimes.length >= 3 && beatTracker) {
    const ivs = [];
    for (let i = 1; i < tapTimes.length; i++) {
      const iv = tapTimes[i] - tapTimes[i-1];
      if (iv > 200 && iv < 1500) ivs.push(iv);
    }
    if (ivs.length) {
      ivs.sort((a, b) => a - b);
      const bpm = Math.round((60000 / ivs[Math.floor(ivs.length / 2)]) * 10) / 10;
      beatTracker.setTarget(bpm);
    }
  }
}

// ================================================================
// CONTROLS
// ================================================================

function renderControls() {
  const el = document.getElementById('controls');
  if (isListening) {
    el.innerHTML = `
      <button class="btn btn-stop" onclick="toggleListening()">STOP</button>
      <button class="btn-secondary" onclick="resetTracker()">RESET</button>
      <button class="btn-secondary" onclick="handleTap()">TAP TEMPO</button>
    `;
  } else {
    el.innerHTML = `<button class="btn btn-start" onclick="toggleListening()">START</button>`;
  }
}

async function toggleListening() {
  if (isListening) { stopListening(); } else { await startListening(); }
}

async function startListening() {
  try {
    const existingErr = document.querySelector('.error-msg');
    if (existingErr) existingErr.remove();

    stream = await navigator.mediaDevices.getUserMedia({
      audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false }
    });

    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    if (audioContext.state === 'suspended') await audioContext.resume();

    const source = audioContext.createMediaStreamSource(stream);
    driftHistory = [];

    const sensVal = parseFloat(document.getElementById('sensitivity').value);
    const filtered = document.getElementById('use-filter').checked;

    beatTracker = createBeatTracker((data) => {
      updateStateBadge(data.state);
      updateBpmDisplay(data);
      updateDriftStatus(data);

      const active = data.state === State.TRACKING && data.currentBpm !== null;
      updateLeds(data.drift, active, data.state);

      if (active && data.currentBpm && data.targetBpm) {
        driftHistory.push({ drift: data.drift, bpm: data.currentBpm, time: performance.now() });
        if (driftHistory.length > MAX_HISTORY) driftHistory.shift();
        updateChart();
      }
    });

    beatTracker.reset();
    beatTracker.startSilenceWatch();
    startWaitingAnimation();

    detector = createOnsetDetector(audioContext, source, (ts) => {
      beatTracker.addOnset(ts);
      beatFlash();
    }, {
      energyThreshold: sensVal,
      useFilter: filtered,
      lowPassFreq: filtered ? 150 : 8000,
      minInterOnsetMs: 100
    });

    isListening = true;
    renderControls();
    document.getElementById('settings').style.opacity = '0.3';
    document.getElementById('settings').style.pointerEvents = 'none';

  } catch (err) {
    const msg = err.name === 'NotAllowedError'
      ? 'Mic access denied — check your browser permissions.'
      : err.name === 'NotFoundError'
      ? 'No microphone found.'
      : `Error: ${err.message}`;
    const errEl = document.createElement('div');
    errEl.className = 'error-msg';
    errEl.textContent = msg;
    document.getElementById('controls').after(errEl);
  }
}

function stopListening() {
  if (detector) { detector.stop(); detector = null; }
  if (beatTracker) { beatTracker.destroy(); beatTracker = null; }
  if (audioContext) { audioContext.close(); audioContext = null; }
  if (stream) { stream.getTracks().forEach(t => t.stop()); stream = null; }
  stopWaitingAnimation();
  isListening = false;
  renderControls();
  updateLeds(0, false, State.IDLE);
  updateStateBadge(State.IDLE);
  updateBpmDisplay({ state: State.IDLE, currentBpm: null, targetBpm: null, drift: 0, confidence: 0, beatCount: 0, calibrationNeeded: 8, gridHits: 0, gridMisses: 0 });
  updateDriftStatus({ state: State.IDLE, drift: 0, currentBpm: null });
  document.getElementById('chart-svg').innerHTML = '';
  document.getElementById('settings').style.opacity = '1';
  document.getElementById('settings').style.pointerEvents = 'auto';
}

function resetTracker() {
  if (beatTracker) beatTracker.reset();
  driftHistory = [];
  updateChart();
  updateLeds(0, false, State.CALIBRATING);
}

// Settings wiring
document.getElementById('sensitivity').addEventListener('input', function() {
  document.getElementById('sens-val').textContent = this.value;
});

// Prevent scrolling
document.addEventListener('touchmove', function(e) { e.preventDefault(); }, { passive: false });

// Wake lock
async function requestWakeLock() {
  try { if ('wakeLock' in navigator) await navigator.wakeLock.request('screen'); } catch (e) {}
}
requestWakeLock();
document.addEventListener('visibilitychange', () => {
  if (document.visibilityState === 'visible') requestWakeLock();
});
</script>
</body>
</html>
